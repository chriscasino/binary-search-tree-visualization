# -*- coding: utf-8 -*-
"""Christian Casino Final Project CIS 4100.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N2GcvA0yvf1BiLqtEzEK26-_i9q2D33n
"""

class BST:
    def __init__(self, root):
        self.root = root
        self.left = None
        self.right = None

# QA of the BST class/constructor: 
# root = BST(10)
# print(f"root.data (root of the BST): {root.data}")
# print(f"root.left (left child of the root on the BST): {root.left}")
# print(f"root.right (right child of the root on the BST): {root.right}")

# print()

# root.left = BST(5)
# print(f"root.left.data (root of the left subtree in the BST): {root.left.data}")
# print(f"root.left.left (left child of the root of the left subtree in the BST): {root.left.left}")
# print(f"root.left.right (right child of the root of the left subtree in the BST): {root.left.right}")


################################################################################

    def insert(self, node_val):
        # if the root of a tree is empty, make the node value parameter the new root
        if self.root is None:
            self.root = node_val
            return

# if the root of the tree is NOT empty, we then need to check whether 
# we can place the the node value, either on the left or the right subtree

  # Condition 1) If the value of the root is higher than that of the node value in the 
  # method's parameter, we will place this node to the LEFT of the node

        if self.root > node_val:
    
    # Condition 1-A)
    # However, we still need to check if the left child of the node is occupied
    # if the root does NOT have a left child, we create a new node to the 
    # left of it by calling the BST class with the node val put in as the root
    # parameter

            if self.left is None:
                self.left = BST(node_val)

    # If the root has a left child, we need to perform the insert operation 
    # again via recursion. In the next iteration of this method, the left
    # child will be made the root, and the method would check to see if 
    # there are any values to the left or the right of it. By a few repeated
    # iterations of the method, a place on the tree will be found where 
    # node_val can be placed as a leaf node
            else:
                self.left.insert(node_val)

  # Condition 2) If the value of the root is lower than that of the node value in the 
  # method's parameter, we will place this node to the RIGHT of the node
        else:

    # Condition 2-A)
    # if the root does NOT have a right child, we create a new node to the 
    # right of it by calling the BST class with the node val put in as the root
    # parameter
            if self.right is None:
                self.right = BST(node_val)
    
    # Condition 2-B)
    # If the root has a right child, we need to perform the insert operation 
    # again via recursion. In the next iteration of this method, the right
    # child will be made the root, and the method would check to see if 
    # there are any values to the left or the right of it. By a few repeated
    # iterations of the method, a place on the tree will be found where 
    # node_val can be placed as a leaf node
            else:
                self.right.insert(node_val)

################################################################################

    def search(self, node_val):

        # When searching through the BST, given a target value, we begin by 
        # first looking at the root of the tree, and checking if it is the target

        if self.root == node_val:
            print("Node is found")
            return

        # If the root is NOT equal to the target, we then check to see if the 
        # value of the node is less than that of the root
        # If it is, we will then search through the nodes to the LEFT
        # of the root
        if node_val < self.root:


        # If we do check the left side of the tree, we first  
        # check to see if the root of the BST has a left child
        # If it does, we will need to run the method again recursively
        # with the root's left child represented as the root (of a subtree) in the new
        # iteration of the method. By a few iterations of the method
        # recursively, we will be able to determine whether the target
        # value is in the tree or not
            if self.left != None:
                self.left.search(node_val)


        # The recursion will bring an the next iteration of the method to the condition above
        # (i.e. "if self.left")
        # if a node to the left of the root does not have children, 
        # that means the target value is not present on the left side of the tree
        # (or the entire tree at all). A message is then printed to the user
        # to notify them
            else:
                print("Sorry, we couldn't find the node that you were looking for!")

        # If the outer if statement condition of node_val < self.root fails,
        # it means that node_val > self.root. If this is the case, we will 
        # check the nodes to the RIGHT of the root
        else:

        # If we do check the right side of the tree, we first  
        # check to see if the root of the BST has a right child
        # If it does, we will need to run the method again recursively
        # with the root's right child represented as the root (of a subtree) in the new
        # iteration of the method. By a few iterations of the method
        # recursively, we will be able to determine whether the target
        # value is in the tree or not
            if self.right != None:
                self.right.search(node_val)

        # The recursion will bring an the next iteration of the method to the condition above
        # (i.e. "if self.right")
        # if a node to the right of the root does not have children, 
        # that means the target value is not present on the right side of the tree
        # (or the entire tree at all). A message is then printed to the user
        # to notify them
            else:
                print("Sorry, we couldn't find the node that you were looking for!")


################################################################################


    def delete(self, node_val):

      # The first thing we do in the delete method is check if the BST is empty
      # if it is, we return a message informing the user as such    
        if self.root == None:
            print("Cannot perform deletion as tree is empty!")
            return self

      # if the BST is NOT empty, we need to find the node that is the target; 
      # that is, the node that we want to delete. 
      # We will first account for searching for a target element to delete 
      # on the left side of the BST (with the condition node_val < self.root)
      # as all nodes that have values less than the root are on the left side
      # of the BST
      # if the target node value is below the root, the node is either in the left
      # of the BST or not at all in the tree

      # to search the node, we will recursively call the delete method
        if node_val < self.root:

        # If the left child of the node is not empty, we will recursively call the 
        # delete method
            if self.left != None:
                self.left = self.left.delete(node_val)
        
        # If the left child of the node IS present, that means the value
        # that we are looking for is NOT in the BST
            else:
                print("Cannot perform deletion as target node value was not found")

      # If the target node value we want to delete is larger that the root 
      # node value we will searchfor the target element to delete 
      # on the right side of the BST (with the condition node_val > self.root)
      # as all nodes that have values greater than the root are on the right side
      # of the BST
      # if the target node value is below the root, the node is either in the right
      # of the BST or not at all in the tree

      # to search the node, we will recursively call the delete method
        elif node_val > self.root:
        # If the right child of the node is not empty, we will recursively call the 
        # delete method
            if self.right != None:
                self.right = self.right.delete(node_val)
        
        # If the right child of the node IS present, that means the value
        # that we are looking for is NOT in the BST
            else:
                print("Cannot perform deletion as target node value was not found")
        

        # if the conditions (if node_val < self.root) and (node_val > self.root)
      # listed above are both false, it means that node_val == self.root, 
      # or the value we want to delete is the root of the tree

      # through the recursion cycles, if a node is succesfully deleted, the program 
      # will end up passing through these conditions below

      # we will need to account for nodes which have (0 children, 1 child or 2 children)  
        else:

        # Accounting for the deletion of nodes with 0 or 1 child
        # if the root node (in a given iteration of the method) does NOT 
        # have a left child
        # We assign a new variable temp to the right child of the current root node
            if self.left == None:
                temp = self.right # if the left child of a node is missing, return the right (opposite) child
                self.root = None # deletes the target node value that was found
                return temp # we return the right child of the node in the current iteration of the method

            if self.right == None:
                temp = self.left # if the right child of a node is missing, return the left (opposite) child
                self.root = None # deletes the target node value that was found
                return temp # we return the right child of the node in the current iteration of the method

        # Deleting nodes that have two children
        # if we replace a node with two children, we will need to move up one of its two children 
        # to take its place. It will either be the largest value in the left subtree or the smallest
        # value in the right subtree
        # whichever option we choose, we replace the root node value with the value of the 
        # child we choose to succeed it as the root. We then delete the location of the child
        # which moved up and became the root of the subtree
        # Below we will see nodes with two children that we want to remove being replaced
        # with the smallest value in the right subtree

            node = self.right # we select the right child of a node and assign it the value node
                              # to refer to the right subtree of a BST

        # we select node.left to get the smallest value in the right subtree
        # selecting node.left will either refer to a node on the left of the subtree
        # or the root of the subtree. This should guarantee getting the smallest value
        # in the subtree
            while node.left != None: # Here we will keep selecting the left most element of the 
                                     # right subtree until the value of node.left is none, meaning 
                                     # that we hit the node on the furthest left of the right subtree
                node = node.left 

            self.root = node.root # replacing the node with two children that we want to remove 
                                  # with the smallest node value in the right sub tree that we found above
      
        # We use this line to delete the former position of the smallest value in the right subtree
        # that we will use to replace the node with two children that we deleted
            self.right = self.right.delete(node.root)

        return self


################################################################################        

# Creating the BST Visualization

# To create the BST visual, we will need to get the height of the tree
# we use the BST method get_height to get the height of the treet
    def get_height(self, node_val):
        if node_val is None:
            return 0

        # The height of a search tree by definition is the number of levels from the root node
        # to the deepest leaf node
        # We need to check both the left side and the right side of the tree
        # By calling the method recursively, we will get the depth of the 
        # both sides of the tree. But recall that the height of the tree is 
        # ALWAYS one more than the depth, which is why we add + 1 to the value 
        # returned by the method
        return max(self.get_height(node_val.left), self.get_height(node_val.right)) + 1

        # The visualize method with the accompanying helper method will be used
        # to create the visualization
    def print_tree(self):
        print("################################################")
        print("###### Visualizing the Binary Search Tree ######")
        print("################################################")
        max_depth = self.get_height(self)
        
        # Here we recursively call the helper method below to get the visualization
        self.print_tree_helper(self, max_depth)
        print("################################################")
        print()

    def print_tree_helper(self, node_val, curr_depth):
      # node_val parameter: represents the node being processed in the current iteration of the method
      # curr_depth: represents the current depth node value is within the binary search tree

      # If node_val is Null, we break out of the recursion/function and go back to the main get_tree function
        if node_val is None:
            return

        # Here we call the helper method via recursion in the EXACT OPPOSITE ORDER
        # of the inorder method. A copy of an inorder tree traversal is provided for reference
        # Recall that for inorder tree traversal method, the left subtree/child of the tree is visited
        # first, followed by the root of the tree, followed by the right subtree/child of the tree

        # Notice that just like the function below, recursive functions are
        # being called to print the left and right children (or left and right subtrees)
        # of a BST, however, a regular print function is called to print the root

        # Unike the method below, the print_tree helper method must contain parameters
        # for the node (as there is only a class for the BST and not the node in this program
        # unlike in the BST Traversal HW program)
        # We also have a parameter for the curr_depth, or the current depth of the node being 
        # referenced as we need to print nodes in the correct position within the correct level
        # on the BST
        self.print_tree_helper(node_val.right, curr_depth + 1)
        print('   ' * (curr_depth - 1) + '->', node_val.root)
        self.print_tree_helper(node_val.left, curr_depth + 1)

# In order method from previous assignment for reference
# def inorder_method(self):
 
#   if self.left: # if the left node of a given subtree is present, call the inorder function recursively on the left node, otherwise, do  nothing
#     self.left.inorder_method()
#   print(self.data, end = " ") # print the root of a tree
#   if self.right: # if the right node of a given subtree is present, call the inorder function recursively on the right node, otherwise, do nothing
#     self.right.inorder_method()


################################################################################
# Applications of the BST Class (2)
# Tree Example #1: 
tree = BST(10)
node_list = [6,36,1,64,98,3,7]
for i in node_list:
  tree.insert(i)

n= 6
print(f"Searching for the element {n} in the BST:")
tree.search(n)

print()
tree.delete(6)
tree.print_tree()

print()

# Tree Example #2: 
tree2 = BST(5)
tree2.insert(5)
tree2.insert(3)
tree2.insert(7)
tree2.insert(2)
tree2.insert(4)
tree2.insert(6)
tree2.insert(8)

tree2.print_tree()